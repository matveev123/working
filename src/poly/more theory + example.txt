public class Task {
    public static void main(String[]args) {
        //System.out.println("1");
        A c1 = new C(); // A
        c1.m1(new B());
		
		
		/*  A c1 = new B(); // B
        c1.m1(new B()); */
    }
}

class A {
    void m1(A a) {// а что если m1(new B())? (см. др.)
        System.out.println("A");
    }
}
class B extends A {
    void m1(B b) {
        System.out.println("B");
    }
}
class C extends B {
    void m1(B c) {
        System.out.println("C");
    }
}


/*class A {
    void m1(A a) {
        System.out.println("from A");
        a.print();
    }
    void print() {
        System.out.print("A");
    }
}
class B extends A {
    void m1(B b) { //overload-перегрузка
        // тело не влияет
    }

    void print() {
        System.out.print("B");
    }
}*/
-----------------------------------------
public void go() {
    А param = new A();
    Object obj = getObject(A);
}

public Object getObject(Object o) {
    return o;
}

Компилятор не знает, что если передать в getObject объект типа A, то и вернётся тоже объект типа A.
Всё, что он учитывает при анализе — это то, что возвращаемый тип у getObject — Object, а значит, в коде A a = getObject(new A());
он не сможет гарантировать, что возвращённый объект будет точно типа A.Поэтому он откажется такое компилировать.

В вашем случае статический тип переменной c1 есть A, у A будет вызвана функция A::m1, 
поскольку ДИНАМИЧЕСКИЙ тип B, как мы выяснили, НЕ ПЕРЕКРЫВАЕТ ПОЛИМОРФНО эту функцию.

потому что переменная c1 имеет тип A и компилятор ищет подходящий метод m1 именно в этом классе и находит только m1(A). 
Он не видит методов производных от A классов даже не смотря на то, что c1 ссылается на объект класса C. 
Все дело в типе самой ссылки, а не в реальном типе объекта. 
Метод m1(B) не замещает метод m1(A), так как у них разные сигнатуры (отличаются списки параметров)

Давайте посмотрим на ваш код глазами компилятора. Он видит в классе A метод m1(A). 
Он просматривает потомков класса A и не видит в них ни одного метода с такой же сигнатурой 
(методы m1(B) из классов B и C не являются полиморфными переопределениеми m1(A) так как у них отличаются сигнатуры). 
Он понимает, что вызовы метода m1(A) он может разрешать на этапе компиляции, что и делает. 
В строчке c1.m1(new B()) он видит вызов m1 из класса A (так как с1 объявлен как объект класса A, метод A.m1 не переопределён ни в одном из потомков, а new B() - потомок класса A)

Всюду, где вы работаете с более общим типом, вы можете указать именно его и при передаче объекта туда конкретного типа произойдёт неявный upcast до нужного. 