Допустим, мы пишем генератор отчетности. У нас есть некий класс, который принимает на вход один из отчетов и выполняет его построение. 
Отчеты у нас разные, но, в общем-то, последовательность их построения одна и та же:

public class ReportBuilder {
    void CreateReport(Report report) {
        data = report.collectData();
        excelFile = this.makeExcel(report, report.template);
        this.publicAndSave(excelFile);
    }
}
Наш класс ReportBuilder 
1)запрашивает данные у класса отчета;
2)размещает их в Excel, запросив у класса отчета шаблон;
3)и сохраняет результат;

Теперь мы можем создать разные классы отчета, которые обладают своими шаблонами своей логикой сбора данных:

abstract class Report {
    DataContainer collectData;
    Strin template();
}

class ReportA extends Report {
    DataContainer collectData() {
		// собираем одни данные
	};

    String template() {
        return "file.xls"
    }
}
class ReportB extends Report {
    DataContainer collectData(){
		// собираем другие данные
	}

    String template() {
        return "file.xls"
    }
}


Допустим, мы пишем генератор отчетности. У нас есть некий класс, который принимает на вход один из отчетов и выполняет его построение. Отчеты у нас разные, но, в общем-то, последовательность их построения одна и та же:

public class ReportBuilder {
   public ReportBuilder() {
   }

   public createReport(Report report) {
      data = report.collectData();
      excelFile = this.makeExcel(report, report.template());
      this.publishAndSave(excelFile); 
   }
}
Наш класс ReportBuilder запрашивает данные у класса отчета, размещает их в Excel, запросив у класса отчета шаблон, и сохраняет результат.

Теперь мы можем создать разные классы отчета, которые обладают своими шаблонами своей логикой сбора данных:

abstract class Report {
   DataContainer collectData();
   String template()
}

class ReportA extends Report {
   DataContainer collectData() {
      // собираем одни данные
   }

   String template() {
      return 'file1.xls';
   }
}

class ReportB extends Report {
   DataContainer collectData() {
      // собираем другие данные
   }

   String template() {
      return 'file1.xls';
   }
}

После этого мы можем делать вот так:
// где-то там
reportBuilder = new ReportBuilder();
reportBuilder.createReport(new ReportA());
reportBuilder.createReport(new ReportB());

Вывод:
Общую логику построения отчетов мы разместили в ReportBuidler : он отвечает за работу с Excel, сохранение и публикацию отчета.
Логика, отвечающая за сбор данных, расположена в классе каждого отчета.
[И полиморфизм - это то, что позволяет передавать объекты разных классов в метод createReport() и быть уверенным, 
что в нем вызовутся методы collectData() и template() соответствующего класса.]


ОЧЕНЬ ХОРОШО:
Полиморфизм - это свойство объекта менять своё поведение во время выполнения. Во время компиляции вызов метода переадресовывыется к классу, 
который его содержит, а во время выполнения к классу из которого он был создан. 
Вы часто используете родительские классы и интерфейсы для определения типа переменной, но создаете объекты подклассов и присваивание ссылку этой переменной.
Например так:
Parent variable = new Child();
Эта переменная может вызывать только методы, определённые в родительском классе, но если эти методы перекрыты в подклассе, то вызов метода переадресовывается в подкласс, в котором этот метод перекрыт.
И поскольку родительский класс может иметь множество подклассов, в которых имеются виртуальные методы с такой же сигнатурой, перекрытые в родительском классе, и имеющими свою имплементацию, 
то вы можете присваивать переменной объект любого из этих подклассов, и тогда будет вызван соответствующий метод подкласса, несмотря на то что в родительском классе этот метод имеет свою имплементацию.
Практически, интерфейсы и абстрактные методы чисто виртуальные, потому что не имеют имплементации, и использование их в коде приводит к полиморфизму, 
поскольку их имплементация находится в подклассах.
На практике мы часто расширяем классы и подменяем изначальную имплементацию на другую и хотим, чтобы оно работало. 

И поскольку оно ничего не знает о наших объектах, то вызывает свои методы не имея ни малейшего понятия, что на самом деле выполнялось. 
Такой подход часто применяется при тестировании, когда вам нужно изменить поведение объектов, за счёт того что вы используете заготовки в рантайме, 
и подставляете их вместо реальных объектов.