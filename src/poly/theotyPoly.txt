Таким образом полиморфизм позволяет абстрагироваться от конкретных реализаций методов,другими словами полиморфизм позволяет делать код менее связанным.

Poly - много phorm - формы
___________________________________________________________________________________________________________________________________________________________
http://strongexperts.narod.ru/ru/articles/archive/java2/2006/apr2006-004/apr2006-004.htm
Полиморфизм (от греч. – “имеющий много форм”).

 

Полиморфизм интерфейсов. Интерфейсы описывают методы, которые должны быть реализованы в классе, и типы параметров, которые должен получать и возвращать каждый член класса, но не содержат определенной реализации методов, оставляя это реализующему интерфейс классу. 
В этом и заключается полиморфизм интерфейсов. Несколько классов могут реализовывать один и тот же интерфейс, в то же время один класс может реализовывать один или больше интерфейсов. Интерфейсы находятся вне иерархии наследования классов, поэтому они исключают определение метода или набора методов из иерархии наследования.

1)Полиморфизм наследования. При наследовании класс получает все методы, свойства и события базового класса такими, какими они реализованы в базовом классе. 
При необходимости в наследуемых классах можно определять дополнительные члены или переопределять члены, доставшиеся от базового класса, чтобы реализовать их иначе. 
Наследуемый класс также может реализовывать интерфейсы. В данном случае полиморфизм проявляется в том, что функционал базового класса присутствует в наследуемых классах неявно. 
Функционал может быть дополнен и переопределен. А наследуемые классы, несущие в себе этот функционал выступают в роли многих форм.

2)Полиморфизм при помощи абстрактных классов. Абстрактные классы поддерживают как наследование, так и возможности интерфейсов. 
При построении сложной иерархии, для обеспечения полиморфизма программисты часто вынуждены вводить методы в классы верхнего уровня при том, что эти методы ещё не определены. 
Абстрактный класс – это класс, экземпляр которого невозможно создать; этот класс может лишь служить базовым классом при наследовании. 
Нельзя объявлять абстрактные конструкторы или абстрактные статические методы. Некоторые или все члены этого класса могут оставаться нереализованными, их реализацию должен обеспечить наследующий класс. 
Производные классы, которые не переопределяют все абстрактные методы, должны быть отмечены как абстрактные. Порожденный класс может реализовывать также дополнительные интерфейсы.

3)Полиморфизм методов Способность классов поддерживать различные реализации методов с одинаковыми именами – один из способов реализации полиморфизма. 
Различные реализации методов с одинаковыми именами в Java называется перегрузкой методов. На языках, которые не поддерживают перегрузку методов, каждому методу необходимо давать уникальное имя. 
На практике часто приходится реализовывать один и тот же метод для различных типов данных. Право выбора специфической версии метода предоставлено компилятору.

4)Отдельным вариантом полиморфизма методов является полиморфизм методов с переменным числом аргументов, введенный в версии Java 2 5.0. 
Перегрузка методов здесь предусмотрена неявно, т.е. перегруженный метод может вызываться с разным числом аргументов, а в некоторых случаях даже без параметров.

5)Перегрузка методов как правило делается для тесно связанных по смыслу операций. Ответственность за построение перегруженных методов и выполнения ими однородных по смыслу операций лежит на разработчике.

6)Полиморфизм через переопределение методов Если перегруженные методы с одинаковыми именами находятся в одном классе, списки параметров должны отличаться. 
Но если метод подкласса совпадает с методом суперкласса (порождающего класса), то метод подкласса переопределяет метод суперкласса. С
овпадать при этом должны и имена методов и типы входных и выходных параметров. 
В данном случае переопределение методов является основой концепции динамического связывания (или позднее связывание), реализующей полиморфизм. 
Суть динамической диспетчеризации методов состоит в том, что решение на вызов переопределенного метода принимается во время выполнения, а не во время компиляции. 
Однако final-методы не являются переопределяемыми, их вызов может быть организован во время компиляции и называется ранним связыванием.
Пример, который иллюстрирует динамическую диспетчеризацию методов (файл Dispatch.java):
class A
{void callme()
 {
  System.out.println(“Метод callme класса A”);
 }
}
class B extends A
{
 //Переопределить callme
 void callme()
 {
  System.out.println(“Метод callme класса B”);
 }
}
class C extends A
{
 //Переопределить callme
 void callme()
 {
  System.out.println(“Метод callme класса С”);
 }
}
class Dispatch
{
 public static void main(String args[])
 {
  A a = new A();        //объект типа A
  B b = new B();        //объект типа B
  C c = new C();        //объект типа C
  A r;                  //определить ссылку типа A
  r = a;                //r указывает на A-объект
  r.callme();           //вызывает A-версию callme
  r = b;                //r указывает на B-объект
  r.callme();           //вызывает B-версию callme
  r = c;                //r указывает на C-объект
  r.callme();           //вызывает C-версию callme
 }
}
В Java все методы используют позднее связывание, если вы не отметите их явно как final. Финальные методы не могут быть переопределены и вызываются быстрее. 
Тот факт, что в Java по умолчанию используется позднее связывание, тогда как в C++ стандартом является раннее связывание, – явный признак разного подхода языков: C++ временами жертвует объектно-ориентированной моделью в пользу эффективности, тогда как Java – наоборот.

7)Полиморфизм через динамическое определение типов (RTTI)
Java позволяет узнать точный тип объекта, когда у вас есть ссылка только на базовый тип. 
Для этого в Java встроено безопасное преобразование типов (type-safe downcast). Cинтаксис безопасного преобразования типов: 
Dog MyDog = (Dog) myAnimal
В случае ошибки выбрасывается исключение. 

8)Полиморфизм представлений Известно, что в ряде
 ситуаций полезен "полиморфизм представлений", когда один объект имеет несколько представлений, оптимизированных для выполнения специфических операций. 
 В идеале эти представления должны поддерживаться на протяжении всего жизненного цикла объекта. 
 Авторы Java предложили частичное решение проблемы полиморфизма представлений, введя "копирующие" конструкторы, создающие новый экземпляр коллекции из элементов существующего набора, быть может, отличающегося реализацией. 
 Например, конструктор TreeSet(Collection c) позволяет представить коллекцию c в виде экземпляра класса TreeSet.

________________________________________________________________________________________________________________________________________________________
https://ru.stackoverflow.com/questions/961534/%d0%9f%d0%be%d0%bb%d0%b8%d0%bc%d0%be%d1%80%d1%84%d0%b8%d0%b7%d0%bc-%d0%b2-java-%d0%b8-%d0%bf%d0%b5%d1%80%d0%b5%d0%b3%d1%80%d1%83%d0%b7%d0%ba%d0%b0?noredirect=1&lq=1
Понятие полиморфизма ввёл в компьютерные науки Кристофер Стрэчи в статье 1967-го года. Вначале он рассматривал математические операторы, которые умеют работать с данными разных типов, например, оператор плюс. 
От операторов он перешёл к функциям, которые также могут обрабатывать данные разных типов.
Если следовать этому — классическому — определению, то перегрузка как раз и позволяет создавать полиморфную функцию, с единственным именем, но разными типами параметров.
Этот вид полиморфизма технически отличается от виртуальных функций, но только технически. По сути это тот же полиморфизм, по крайней мере, в терминологии Стрэчи. 
Виртуальная функция в первом параметре неявно получает ссылку на объект (this). Страустрап описывает этот механизм в своей книге по C++. Он же (механизм) применяется и в JVM, и в .NET. 
Получается, что виртуальный метод полиморфен потому, что может работать с разными типами своего неявного первого параметра.
Перегрузка относится к так называемому ad hoc полиморфизму. Это название означает, что нам нужно писать разные версии функции для разных типов.
Другой вид полиморфизма — параметрический, характерный для обобщённого программирования (generic programming).
Метод List<T>.add() умеет добавлять в список данные разных типов, и его код вы пишите всего один раз
Итого, получается, что в Java полиморфизм, описанный Стрэчи доступен посредством:
Виртуальных функций.
Перегрузки функций.
Обобщённых функций.??? generic ???
Первые два способа — ad hoc полиморфизм, последний — параметрический полиморфизм.

ОЧЕНЬ ХОРОШО: Полиморфизм - это возможность применения одноименных методов с одинаковыми или различными наборами параметров в одном классе или в группе классов, связанных отношением наследования.
ОЧЕНЬ ХОРОШО: Полиморфизм - принцип объектно-ориентированного программирования, обеспечивающий работу метода класса-потомка, перекрывающего виртуальный метод класса-предка, при использовании интерфейса переменной класса-предка, если в переменной размещен объект класса-потомка.

ОЧЕНЬ ХОРОШО:Все логично. Вы расширяете класс с помощью наследования. doSomething это поведение характерное именно Man, то есть и вызвать вы его можете только на объекте Man. 
Для аналогии представьте себе класс "фигура", и куча наследников (квадрат, окружность и т.д.) И допустим у класса окружность есть метод getRadius. 
Как вы будете вызывать его на ФИГУРЕ, а не на ОКРУЖНОСТИ? ведь не у каждой фигуры есть радиусе. Как такой метод должен работать на квадрате? 


 

