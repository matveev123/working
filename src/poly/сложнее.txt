Не совсем. Объект не меняет своё поведение. Поведение всегда завязано тем, какой конкретный тип объекта ты используешь. 
Полиморфизм же позволяет подменять один тип другим, с таким же "интерфейсом". Реализация при этом может быть другая.

Другими словами, если взять определение полиморфизма с интернетов, которое мне понавилось:
Полиморфизм - свойство семантики системы типов, позволяющее обрабатывать значения разных типов идентичным образом, 
то есть исполнять физически один и тот же код для данных разных типов.

Это определение куда шире, чем кажется и относится не только к наследованию. Пара примеров:

1. Полиморфизм с наследованием

У тебя есть метод applyParser(Parser), который принимает объект Парсера, который имеет метод parse(String) -> Tokens. 
И у тебя есть два наследника этого парсера: XmlParser и JsonParser. Не важно, какой парсер ты передашь в метод "applyParser", язык сможет с ним работать, 
потому что [с точки зрения метода оба объекта имеют одинаковый интерфейс], ограниченный их общим родителем Parser.

2. Полиморфизм с генериками

У тебя есть метод chunk(List, Integer) -> List<List>, который разбивает список на блоки определенной длины. 
Методу плевать на тип элементов, который будет в листе. Метод сможет одинакого эффективно использовать списки с интами, с объектами и так далее.

Для того, чтобы работал первый пример, используется виртуальная таблица методов, которая в "рантайме" смотрит "настоящий" метод объекта по таблице. 
Антон уже про это написал.

Для того, чтобы работал второй пример, используются разные механизмы. В джаве например это генерики, в с++ темплейты.